#' ---
#' title: "metadata_bc.R"
#' author: "Dean Koch"
#' date: "June 25, 2020"
#' output: github_document
#' ---
#'
#' **Development version**: testing R code for preparing metadata list
#' eventually this may be turned into a public component of the rasterbc package, allowing
#' users to recreate all the steps used in preparing the dataset, and/or add their new collections
#'
#' For now it serves to record the steps for getting from the rasterbc_src repo output to the metadata_BC
#' list, which is saved as external data (in subdirectory data/) of the rasterbc package with a link in the
#' documentation to the rasterbc_src repo, where there is ample documentation of the sourcing workflow.
#'
#' This script has some information on filepaths that is specific to my workstation, so it is not intended for
#' distribution in the rasterbc package.
#'

library(here)
library(devtools)
#library(rasterbc)
load_all()

# URL at FRDR where the files are currently hosted (for now, a demo version only!)
cfg.data.url = 'https://364cb.0ec8.dn.glob.us/1/published/publication_222/submitted_data/'

# current location on my machine to look for metadata generated by the scripts in the rasterbc_src repo
current.data.dir = 'H:/git-MPB/rasterbc_src/data/'

# path to original storage location (from when metadata files were written)
original.data.dir = 'H:/git-MPB/rasterbc/data/'

# for now, we only have the DEM data hosted, but this code should work for the whole collection
collections = unlist(strsplit(list.files(current.data.dir)[endsWith(list.files(current.data.dir), '.rds')], '.rds'))
metadata_bc = vector(mode='list', length=length(collections))
names(metadata_bc) = collections

# load the metadata and convert output filenames to web urls
for(collection in collections)
{
  # read in the metadata created by the src_*.R script
  cfg = readRDS(file.path(current.data.dir, paste0(collection, '.rds')))
  cfg.fname = listswap_bc(cfg$out$fname$tif, paste0(original.data.dir, collection, '/'), '')
  # after adding the rest of the collections, need to change this to:
  # cfg.fname = listswap_bc(cfg$out$fname$tif, original.data.dir, '')
  cfg.src = listswap_bc(cfg$src[names(cfg$src) != 'dir'], original.data.dir, '')
  cfg.codes = cfg$out$code
  metadata_bc[[collection]] = list(source=cfg.src, frdr=cfg.data.url, fname=cfg.fname, metadata=list(coding=cfg.codes))
}

# the 'pine' layers have their cfg.src$years entry as character strings. Replace these with integers
metadata_bc[['pine']]$source$years = setNames(as.integer(metadata_bc[['pine']]$source$years), nm=names(metadata_bc[['pine']]$source$years))

# add a list to the metadata entry specifying a printout of all varnames
# prepare the full list of available variables as a nested list of strings to print on console
collections.lyrs = lapply(metadata_bc, function(collection) setNames(nm=names(collection$fname$block)))
for(collection in names(collections.lyrs))
{
  metadata_bc[[collection]]$metadata$varnames = collections.lyrs[[collection]]

  # check if this collection is/contains a time-series (a year-indexed set of rasters)...
  collection.years = metadata_bc[[collection]]$source$years
  if(!is.null(collection.years))
  {
    # ... if so, check which variables are associated with time-series
    is.year = setNames(grepl('(yr)(\\d+)', collections.lyrs[[collection]]), collections.lyrs[[collection]])

    # check which variables are available in which years
    lyrs.byyear = lapply(which(is.year), function(idx.year) names(metadata_bc[[collection]]$fname$block[[idx.year]]))
    ts.lyrs = unique(unlist(lyrs.byyear))
    lyr.year.matrix = sapply(ts.lyrs, function(lyr) sapply(lyrs.byyear, function(year) lyr %in% year))

    # for each variable, construct a string indicating the available years
    lyr.string.list = setNames(nm=ts.lyrs)
    for(lyr in lyr.string.list)
    {
      available.years = collection.years[names(which(lyr.year.matrix[, lyr]))]

      # strings for printing time series info into console
      ts.yrstring = paste(available.years, collapse=', ')
      if(identical(unname(available.years), min(available.years):max(available.years)))
      {
        # if the years are sequential, use a short-form string (eg. "2001-2018")
        ts.yrstring = paste(range(available.years), collapse='-')
      }
      lyr.string.list[[lyr]] = paste0(lyr.string.list[[lyr]], ' (years ', ts.yrstring, ')')
    }

    # write this list to metadata_bc
    metadata_bc[[collection]]$metadata$varnames = c(collections.lyrs[[collection]][!is.year], lyr.string.list)
  }
}

# to do: transfer some of the metadata, add units etc

# write to data directory for package
use_data(metadata_bc, overwrite=TRUE)

