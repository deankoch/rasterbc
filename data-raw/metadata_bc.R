#' ---
#' title: "metadata_bc.R"
#' author: "Dean Koch"
#' date: "June 25, 2020"
#' output: github_document
#' ---
#'
#' **Development version**: testing R code for preparing metadata list
#' eventually this may be turned into a public component of the rasterbc package, allowing
#' users to recreate all the steps used in preparing the dataset, and/or add their new collections
#'
#' For now it serves to record the steps for getting from the rasterbc_src repo output to the metadata_BC
#' list, which is saved as external data (in subdirectory data/) of the rasterbc package with a link in the
#' documentation to the rasterbc_src repo, where there is ample documentation of the sourcing workflow.
#'
#' This script has some information on filepaths that is specific to my workstation, so it is not intended for
#' distribution in the rasterbc package.
#'

library(here)
library(devtools)
#library(rasterbc)
load_all()

# URL at FRDR where the files are currently hosted (for now, a demo version only!)
cfg.frdr = 'https://364cb.0ec8.dn.glob.us/1/published/publication_227/submitted_data/'

# current location on my machine to look for metadata generated by the scripts in the rasterbc_src repo
current.data.dir = 'H:/git-MPB/rasterbc_src/data/'

# path to original storage location (from when metadata files were written)
original.data.dir = 'H:/git-MPB/rasterbc/data/'

# for now, we only have the DEM data hosted, but this code should work for the whole collection
collections = unlist(strsplit(list.files(current.data.dir)[endsWith(list.files(current.data.dir), '.rds')], '.rds'))
metadata_bc = vector(mode='list', length=length(collections))
names(metadata_bc) = collections

# load the metadata and convert output filenames to web urls
for(collection in collections)
{
  # read in the metadata created by the src_*.R script
  cfg = readRDS(file.path(current.data.dir, paste0(collection, '.rds')))
  cfg.fname = listswap_bc(cfg$out$fname$tif, paste0(original.data.dir, collection, '/'), '')
  cfg.src = listswap_bc(cfg$src[names(cfg$src) != 'dir'], original.data.dir, '')
  cfg.codes = cfg$out$code
  cfg.data.url = paste0(cfg.frdr, collection, '/')
  metadata_bc[[collection]] = list(source=cfg.src, frdr=cfg.data.url, fname=cfg.fname, metadata=list(coding=cfg.codes))
}

# the 'pine' layers have their cfg.src$years entry as character strings. Replace these with integers
metadata_bc[['pine']]$source$years = setNames(as.integer(metadata_bc[['pine']]$source$years), nm=names(metadata_bc[['pine']]$source$years))

# add a list to the metadata entry specifying a printout of all varnames
# prepare the full list of available variables as a nested list of strings to print on console
collections.lyrs = lapply(metadata_bc, function(collection) setNames(nm=names(collection$fname$block)))
for(collection in names(collections.lyrs))
{
  # assign the variable names based on the block directory names
  metadata_bc[[collection]]$metadata$varnames = collections.lyrs[[collection]]

  # check if this collection is/contains a time-series (a year-indexed set of rasters)...
  collection.years = metadata_bc[[collection]]$source$years
  if(!is.null(collection.years))
  {
    # ... if so, check which variables are associated with time-series
    is.year = setNames(grepl('(yr)(\\d+)', collections.lyrs[[collection]]), collections.lyrs[[collection]])

    # check which variables are available in which years
    lyrs.byyear = lapply(which(is.year), function(idx.year) names(metadata_bc[[collection]]$fname$block[[idx.year]]))
    ts.lyrs = unique(unlist(lyrs.byyear))
    lyr.year.matrix = sapply(ts.lyrs, function(lyr) sapply(lyrs.byyear, function(year) lyr %in% year))

    # for each variable, construct a string indicating the available years
    lyr.string.list = setNames(nm=ts.lyrs)
    for(lyr in lyr.string.list)
    {
      available.years = collection.years[names(which(lyr.year.matrix[, lyr]))]

      # strings for printing time series info into console
      lyr.string.list[[lyr]] = paste(available.years, collapse=', ')
      if(identical(unname(available.years), min(available.years):max(available.years)))
      {
        # if the years are sequential, use a short-form string (eg. "2001-2018")
        lyr.string.list[[lyr]] = paste(range(available.years), collapse='-')
      }
    }

    # reorder the fids collection to group species together
    if(collection == 'fids')
    {
      new.index = rep(NA, length(lyr.string.list))
      new.index.pointer = 0
      for(species in names(metadata_bc[[collection]]$source$spp.codes))
      {
        for(stat in c('min','mid','max', names(metadata_bc[[collection]]$source$sev.codes$post2003)))
        {
          new.index.pointer = new.index.pointer + 1
          new.index[new.index.pointer] = which(paste0(species, '_', stat) == names(lyr.string.list))
        }
      }

      lyr.string.list = lyr.string.list[new.index]
    }

    # write this list to metadata_bc
    metadata_bc[[collection]]$metadata$varnames = setNames(nm=c(collections.lyrs[[collection]][!is.year], names(lyr.string.list)))
    metadata_bc[[collection]]$metadata$years = c(rep(NULL, sum(!is.year)), lyr.string.list)
  }
}

# to do: transfer some of the metadata, add units etc
metadata_bc$dem$metadata$units = setNames(c('metres', 'degrees', 'degrees'), metadata_bc$dem$metadata$varnames)
metadata_bc$dem$metadata$details = setNames(c('above sea level', 'from horizontal', 'counterclockwise from North'), metadata_bc$dem$metadata$varnames)

# write to data directory for package
use_data(metadata_bc, overwrite=TRUE)

